-- PELCOP的协议主要在于校验不一样，这个２－６位字节求异或

local Protocol = {};

-- 表示数值可以用16或10进制(最小值，最大值)
Protocol.Attr = 
{
		-- 协议的显示名称,不能超过16字符
		Name = "PELCOP",	
		
		-- 指明是云台协议还是矩阵协议
		Type = "PTZ",
		
		-- 以ms为单位.云台超时时间取自lua脚本，lua脚本的超时时间一直是200ms。以前remoteservice会把这个时间*2作为超时时间，后来切DVRIP后没有*2的操作了，导致网络不太好时就会超时，超时后DVRIP就会下发停止云台命令，现象就是云台卡顿。现在把lua脚本里的超时时间改为400ms。注：网络很差或设备很卡时可能还会出现卡顿。
		Internal = 400,
			
		-- 云台地址范围
		CamAddrRange 		= {0x01, 0x1F}, 
		-- 监视地址范围
		MonAddrRange		= {0x00, 0xFF},	
		-- 预置点范围
		PresetRange 		= {0x00, 0xFF},
		-- 自动巡航线路范围
		TourRange			= {0x01, 0x01},
		-- 轨迹线路范围
		PatternRange		= {0x01, 0x05},
		-- 垂直速度范围
		TileSpeedRange 		= {0x01, 0x3F},
		-- 水平速度范围
		PanSpeedRange 		= {0x01, 0x3F},
		-- 自动扫描范围
		ScanRange 			= {0x01, 0x05},
		
		-- 辅助范围
		AuxRange 			= {0x01, 0x08},
}

Protocol.CommandAttr =
{
	-- 协议中需要更改的位置，用LUA下标表示，即下标从１开始
	AddrPos = 2, 
	PresetPos = 6, 
	TileSpeedPos = 6,
	PanSpeedPos = 5,
	AuxPos = 6,
}


Protocol.Command = 
{
	-- 写具体协议时只能用16进制或字符表示, 没有
	Start= 
	{
		--写上下左右, 左上，左下，右上，右下
		TileUp 		= "0xa0, 0x00, 0x00, 0x08, 0x00, 0x1F, 0xaf, 0x00,",
		TileDown 	= "0xa0, 0x00, 0x00, 0x10, 0x00, 0x1F, 0xaf, 0x00,",
		PanLeft 	= "0xa0, 0x00, 0x00, 0x04, 0x2f, 0x00, 0xaf, 0x00,", 
		PanRight 	= "0xa0, 0x00, 0x00, 0x02, 0x2f, 0x00, 0xaf, 0x00,",
		LeftUp 		= "0xa0, 0x00, 0x00, 0x0c, 0x2f, 0x00, 0xaf, 0x00,",
		LeftDown 	= "0xa0, 0x00, 0x00, 0x14, 0x2f, 0x00, 0xaf, 0x00,",
		RightUp		= "0xa0, 0x00, 0x00, 0x0a, 0x2f, 0x00, 0xaf, 0x00,",
		RightDown = "0xa0, 0x00, 0x00, 0x12, 0x2f, 0x00, 0xaf, 0x00,",
		
		ZoomWide 	= "0xa0, 0x00, 0x00, 0x40, 0x00, 0x00, 0xaf, 0x00",
		ZoomTele 	= "0xa0, 0x00, 0x00, 0x20, 0x00, 0x00, 0xaf, 0x00,",
		FocusNear 	= "0xa0, 0x00, 0x02, 0x00, 0x00, 0x00, 0xaf, 0x00,",
		FocusFar 	= "0xa0, 0x00, 0x01, 0x00, 0x00, 0x00, 0xaf, 0x00",
		IrisSmall	= "0xa0, 0x00, 0x08, 0x00, 0x00, 0x00, 0xaf, 0x00,",
		IrisLarge 	= "0xa0, 0x00, 0x04, 0x00, 0x00, 0x00, 0xaf, 0x00",
			
		-- 灯光
		LightOn		= "0xa0, 0x00, 0x50, 0x00, 0x00, 0x00, 0xaf,0x00",
		LightOff  	= "0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf,0x00",
			
		-- 预置点操作（设置，清除，转置)
		SetPreset 	= "0xa0, 0x00, 0x00, 0x03, 0x00, 0x21, 0xaf, 0x00",
		ClearPreset	= "0xa0, 0x00, 0x00, 0x05, 0x00, 0x21, 0xaf, 0x00",
		GoToPreset 	= "0xa0, 0x00, 0x00, 0x07, 0x00, 0x21, 0xaf, 0x00",			
		
		-- 精确定位命令
		PositionAbs = "0xa0, 0x01, 0x00, 0x4b, 0x00, 0x00, 0xaf, 0x00, 0xa0, 0x01, 0x00, 0x4d, 0x00, 0x00, 0xaf, 0x00, 0xa0, 0x01, 0x00, 0x4f, 0x00, 0x00, 0xaf, 0x00",
		
		-- 绝对移动命令
		AbsoluteStart = "0xa0, 0x01, 0x00, 0x4b, 0x00, 0x00, 0xaf, 0x00, 0xa0, 0x01, 0x00, 0x4d, 0x00, 0x00, 0xaf, 0x00, 0xa0, 0x01, 0x00, 0x4f, 0x00, 0x00, 0xaf, 0x00",
		AbsoluteStop = "0xa0, 0x01, 0x00, 0x00, 0x00, 0x00, 0xaf, 0x0e",
		
		--持续移动命令
		ContinueStart = "0xa0, 0x01, 0x00, 0x00, 0x00, 0x00, 0xaf, 0xff",
		ContinueStop = "0xa0, 0x01, 0x00, 0x00, 0x00, 0x00, 0xaf, 0x0e",
			
		-- 水平旋转，在预先设置的边界中间转动
		SetLeftLimit 	= "0xa0, 0x00, 0x00, 0x11, 0x00, 0x21, 0xaf, 0x00",
		SetRightLimit	= "0xa0, 0x00, 0x00, 0x13, 0x00, 0x21, 0xaf, 0x00", 
		AutoScanOn 		= "0xa0, 0x00, 0x00, 0x1B, 0x00, 0x21, 0xaf, 0x00",
		AutoScanOff		= "0xa0, 0x00, 0x00, 0x1D, 0x00, 0x21, 0xaf, 0x00",
		
		-- 轨迹巡航, 一般指模式(设置开始，设置结束，运行，停止，清除模式
		SetPatternStart = "0xa0, 0x00, 0x00, 0x1f, 0x00, 0x01, 0xaf, 0x00",
		SetPatternStop 	= "0xa0, 0x00, 0x00, 0x21, 0x00, 0x01, 0xaf, 0x00",
		StartPattern 	= "0xa0, 0x00, 0x00, 0x23, 0x00, 0x01, 0xaf, 0x00",
		StopPattern     = "0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf, 0x00,",
		
		AuxOn 	= "0xa0, 0x00, 0x00, 0x09, 0x00, 0x21, 0xaf, 0x00,",
		AuxOff 	= "0xa0, 0x00, 0x00, 0x0b, 0x00, 0x21, 0xaf, 0x00,",
		
	},
	Stop = 
	{
		TileUp 		= "0xa0, 0x0, 0x00, 0x0, 0x0, 0x0, 0xaf,0x0,",
		TileDown 	= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0",
		PanLeft 	= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0",
		PanRight 	= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0",
		LeftUp 		= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0,",
		LeftDown 	= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0,",
		RightUp		= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0,",
		RightDown 	= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0,",
			
		ZoomWide 	= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0,",
		ZoomTele 	= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0,",
		FocusNear 	= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0,",
		FocusFar 	= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0,",
		IrisSmall 	= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0,",
		IrisLarge	= "0xa0,0x0,0x00,0x0,0x0, 0x0, 0xaf,0x0,",
	},
}

Protocol.Checksum = function (s)
	local value = s[1];
	for i = 2, 7 do
		value = bits.bxor(value,s[i]);
	end;
	s[8] = math.mod(value, 256);
	return s;
end;

Protocol.PatternProcess = function(s, num)
	s[6] = num;
	return s;	
end;

Protocol.SetLeftLimitProcess = function(s, num)
	s[6] = num;
	return s;	
end;

Protocol.SetRightLimitProcess = function(s, num)
	s[6] = num;
	return s;	
end;

Protocol.AutoScanOnProcess = function(s, num)
	s[6] = num;
	return s;	
end;

Protocol.AutoScanOffProcess = function(s, num)
	s[6] = num;
	return s;	
end;

--[[
云台精确定位
arg1:水平坐标
arg2：垂直坐标
arg3：ZOOM坐标
--]]
Protocol.PositionAbsProcess = function(s,arg1, arg2, arg3, T)
	--下面只处理云台精确定位功能
	
	arg1 = arg1*10;
	--垂直坐标系转换
	if arg2 < 0 then
		arg2 = arg2 + 3600;
	end
	arg2 = arg2 * 10;
	arg3 = (arg3/128)*65535;
	--PositionAbs = "0xa0, 0x01, 0x00, 0x4b, 0x00, 0x00, 0xaf, 0x00, 0xa0, 0x01, 0x00, 0x4d, 0x00, 0x00, 0xaf, 0x00, 0xa0, 0x01, 0x00, 0x4f, 0x00, 0x00, 0xaf, 0x00";
	if s[1] == 0xa0 then
		--水平坐标
		s[5] = bits.band(arg1,0xff00)/256;
		s[6] = bits.band(arg1,0xff);
		
		local value = s[1];
		for i = 2, 7 do
			value = bits.bxor(value,s[i]);
		end;
		s[8] = math.mod(value, 256);
		
		--垂直坐标
		s[13] = bits.band(arg2,0xff00)/256;
		s[14] = bits.band(arg2,0xff);
		
		value = s[9];
		for i = 10, 15 do
			value = bits.bxor(value,s[i]);
		end;
		s[16] = math.mod(value, 256);
		
		--变倍值
		s[21] = bits.band(arg3,0xff00)/256;
		s[22] = bits.band(arg3,0xff);
		
		value = s[17];
		for i = 18, 23 do
			value = bits.bxor(value,s[i]);
		end;
		s[24] = math.mod(value, 256);

		return s;
	end;
end;

--[[
云台绝对定位
arg1:水平坐标
arg2：垂直坐标
arg3：ZOOM坐标
--]]

Protocol.AbsoluteStartProcess = function(s,arg1, arg2, arg3, T)
	local xValue = bits.rshift(arg1, 16);
	--Onvif垂直坐标有负数
	local yValue = arg2/(256*256);
	local zValue = bits.rshift(arg3, 16);

	xValue = xValue*10;
	--垂直坐标系转换
	if yValue < 0 then
		yValue = yValue + 3600;
	end;
	yValue = yValue*10;
	zValue = (zValue/128)*65535;
	--下面只处理绝对移动功能
	--AbsoluteStart = "0xa0, 0x01, 0x00, 0x4b, 0x00, 0x00, 0xaf, 0x00, 0xa0, 0x01, 0x00, 0x4d, 0x00, 0x00, 0xaf, 0x00, 0xa0, 0x01, 0x00, 0x4f, 0x00, 0x00, 0xaf, 0x00";
	if s[1] == 0xa0 then
		--水平位置
		s[5] = bits.rshift(bits.band(xValue,0xff00), 8);
		s[6] = bits.band(xValue,0xff);
		
		local value = s[1];
		for i = 2, 7 do
			value = bits.bxor(value,s[i]);
		end;
		s[8] = math.mod(value, 256);
		
		--垂直位置
		s[13] = bits.rshift(bits.band(yValue,0xff00), 8);
		s[14] = bits.band(yValue,0xff);
		
		value = s[9];
		for i = 10, 15 do
			value = bits.bxor(value,s[i]);
		end;
		s[16] = math.mod(value, 256);
		
		--变倍值
		s[21] = bits.rshift(bits.band(zValue,0xff00), 8);
		s[22] = bits.band(zValue,0xff);
		
		value = s[17];
		for i = 18, 23 do
			value = bits.bxor(value,s[i]);
		end;
		s[24] = math.mod(value, 256);
		
		return s;
	end;
end;

--[[
云台持续移动
arg1:水平速度
arg2：垂直速度
arg3：ZOOM速度
T：超时时间
--]]
Protocol.ContinueStartProcess = function(s, arg1, arg2, arg3, T)
	--下面只处理持续移动功能		
	if s[1] == 0xa0 then
		--处理水平控制
		if arg1 > 0 then
			s[4] = 0x02;
		elseif arg1 < 0 then
			s[4] = 0x04;
		else
			s[4] = 0x00;
		end
		--处理垂直控制
		if arg2 > 0 then
			s[4] = bits.bor(s[4], 0x08);
		elseif arg2 < 0 then
			s[4] = bits.bor(s[4], 0x10);
		end
		--处理变倍控制
		if arg3 > 0 then
			s[4] = bits.bor(s[4], 0x20);
		elseif arg3 < 0 then
			s[4] = bits.bor(s[4], 0x40);
		end
		--处理水平速度，范围(0,3f),Onvif范围(0, ff)
		s[5] = math.abs(arg1)/4;
		--处理垂直速度，范围(0,3f),Onvif范围(0, ff)
		s[6] = math.abs(arg2)/4;
		
		local value = s[1];
		for i = 2, 7 do
			value = bits.bxor(value,s[i]);
		end;
		s[8] = math.mod(value, 256);
		
		return s;
	end
end;

Protocol.StopProcess = function(s, arg1)
	if s[1] == 0xa0 then
		local value = s[1];
		for i = 2, 7 do
			value = bits.bxor(value,s[i]);
		end;
		s[8] = math.mod(value, 256);
		
		return s;
	end	
end
--[[
--下面的函数是可选的，除非有特殊处理过程才打开，没有的话，千万不要打开，否则会造成解析出错
Protocol.CamAddrProcess = function(s, addr)
	-- 传入的地址0代表camaddr 1
	s[Protocol.CommandAttr.AddrPos] = addr;
	return s;
end;

Protocol.MonAddrProcess = function(s, addr)
	return s;
end;

Protocol.SpeedProcess = function(s, arg1, arg2)
	return s;
end;

Protocol.PresetProcess = function(s, arg1, arg2))
	return s;
end;
--]]

return Protocol;